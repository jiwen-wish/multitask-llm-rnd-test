#%%
import pandas as pd
import numpy as np
import dvc.api
import os
import yaml
from sklearn.metrics import classification_report
from pprint import pprint


main_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))

# configurable
data_config_relpath = "datasets/multimodal_multitask/wish_labelled_query_offshore_test.yaml"
data_split = "test"
data_source_type = "dvc"
inference_output_relpath = "models/product_title_multitask_multimodal/version_1/clm-epoch=0-step=75000--wish_labelled_query_offshore_test--test.json"
num_return_sequences = 3
tax_data_config = {
    "path": "data/taxonomy/wish_newtax.json",
    "repo": "git@github.com:junwang-wish/query_understanding_data.git",
    "rev": None
}
baseline_data_config = {
    "path": "data/query/wish_queries_inferred_newtax.json",
    "repo": "git@github.com:junwang-wish/query_understanding_data.git",
    "rev": None
}
min_prob = -1
min_baseline_weight = -1
eval_top_k = 3

# if __name__ == "__main__":
#     pass

#%%
data_config = yaml.safe_load(open(os.path.join(main_path, data_config_relpath), 'r'))
assert data_split in data_config and len(data_config[data_split]) == 1
if data_source_type == "dvc":
    df_in = pd.read_json(dvc.api.get_url(**data_config[data_split][0]), lines=True)
else:
    raise NotImplemented()
df_out = pd.read_json(os.path.join(main_path, inference_output_relpath), lines=True)
assert len(df_out) == int(num_return_sequences * len(df_in))
df_baseline = pd.read_json(dvc.api.get_url(**baseline_data_config), lines=True)
df_tax = pd.read_json(dvc.api.get_url(**tax_data_config), lines=True)

# %%
df_in['query_classification_lists'] = df_in['query_classification_lists'].apply(
    lambda x: [i.lower() for i in x]
)
df_tax['category_path'] = df_tax['category_path'].str.lower()
taxstrid2path = {}
for i in df_tax.to_dict('records'):
    if len(i['category_path']) > 0:
        taxstrid2path[str(i['id'])] = i['category_path']
df_baseline['y_baseline'] = df_baseline['categories'].apply(
    lambda x: [taxstrid2path[i] for i in x.split(',')]
)
df_baseline['y_baseline_prob'] = df_baseline['weights'].apply(
    lambda x: [float(i) for i in x.split(',')]
)
df_out_group = df_out.groupby('batch_indices').agg(
    {
        'prediction_decoded': lambda x: [i for i in x], 
        'prob': lambda x: [i for i in x]
    }).sort_index()
#%%
valid_paths = {}
valid_paths_rev = {}
for i in df_tax.to_dict('records'):
    if len(i['category_path']) > 0:
        valid_paths[i['category_path']] = len(valid_paths)
for i in df_in.to_dict('records'):
    for j in i['query_classification_lists']:
        assert j in valid_paths
for i in df_out_group.to_dict('records'):
    for j in i['prediction_decoded']:
        assert j in valid_paths

valid_paths_rev = {valid_paths[i]: i for i in valid_paths}
valid_paths_list = [valid_paths_rev[i] for i in range(len(valid_paths_rev))]

df_join = df_in.copy()[['query', 'sample_method', 'gmv', 'cnt', 
        'query_classification_lists']].rename(
    columns={'query_classification_lists': 'y_true'})
df_join['y_pred'] = df_out_group['prediction_decoded'].tolist()
df_join['y_prob'] = df_out_group['prob'].tolist()

df_join_baseline = df_join.merge(df_baseline[['query', 'y_baseline', 'y_baseline_prob']], 
    on='query', how='inner')

# %%
def calculate_metrics(df_join, min_prob, valid_paths, y_true_name="y_true", 
        y_pred_name="y_pred", y_prob_name="y_prob"):
    perfs = []
    for depth_constraint in [1, 2, 3, 4, 5]:
        # build label indicator array
        y_true_indicator = np.zeros((len(df_join), len(valid_paths)))
        y_pred_indicator = np.zeros((len(df_join), len(valid_paths)))
        for ind, i in enumerate(df_join.to_dict('records')):
            for j in i[y_true_name][:eval_top_k ]: 
                path = " > ".join(j.split(" > ")[:depth_constraint])
                y_true_indicator[ind, valid_paths[path]] = 1.
            for j, j_prob in list(zip(i[y_pred_name], i[y_prob_name]))[:eval_top_k ]:
                path = " > ".join(j.split(" > ")[:depth_constraint])
                if j_prob >= min_prob:
                    y_pred_indicator[ind, valid_paths[path]] = 1.
        perf = pd.DataFrame(classification_report(
            y_true=y_true_indicator,
            y_pred=y_pred_indicator,
            output_dict=True, 
            zero_division=0,
            target_names=valid_paths_list
        )).T.reset_index().rename(columns={'index':'id'})
        perf['depth_constraint'] = depth_constraint
        perfs.append(perf)
    df_perf = pd.concat(perfs)
    df_perf_agg = df_perf[df_perf['id'] == 'weighted avg']
    return df_perf, df_perf_agg

# %%
df_perf, df_perf_agg = calculate_metrics(df_join, min_prob, valid_paths, y_true_name="y_true", 
        y_pred_name="y_pred", y_prob_name="y_prob")
df_sub_perf, df_sub_perf_agg = calculate_metrics(df_join_baseline, min_prob, valid_paths, 
        y_true_name="y_true", y_pred_name="y_pred", y_prob_name="y_prob")
df_sub_perf_baseline, df_sub_perf_agg_baseline = calculate_metrics(df_join_baseline, min_baseline_weight, 
        valid_paths, y_true_name="y_true", y_pred_name="y_baseline", y_prob_name="y_baseline_prob")
# %%
langs = """de
en
en
en
en
en
en
en
en
fr
en
en
en
en
en
en
sv
en
es
en
en
pt
en
en
en
en
en
en
es
en
la
en
pt
en
de
it
pt
en
pt
en
en
it
en
en
pt
en
en
en
en
el
en
pt
en
en
en
bg
it
pt
en
en
en
en
en
pt
en
it
it
en
it
it
la
it
en
lt
de
en
en
fr
ar
en
de
en
pl
en
bg
en
en
en
pt
en
en
en
en
it
en
en
en
fr
en
en
ro
es
pt
en
en
en
es
en
en
fr
de
en
en
nl
en
en
en
en
pt
en
en
en
de
en
es
it
en
gl
es
fr
de
fr
en
es
en
es
en
pt
en
en
ar
en
en
da
en
es
de
en
en
it
en
la
en
en
en
en
en
en
en
fr
pt
sv
en
az
pt
de
en
pt
en
en
en
fil
en
en
en
en
en
de
en
fr
en
en
en
en
en
en
fr
en
en
en
en
en
en
de
en
en
en
de
en
en
fr
la
en
ja
en
en
en
en
en
en
en
en
de
en
en
pt
en
lt
en
en
fr
en
en
es
en
en
fr
es
en
en
fr
it
en
en
en
es
en
pt
de
en
pt
es
en
en
en
en
en
en
es
en
de
en
en
en
en
en
en
fr
en
en
en
en
de
en
en
ja
de
es
en
en
en
en
de
en
en
en
en
en
en
en
en
en
de
de
es
en
fi
fr
es
en
en
en
en
en
pt
it
en
en
pt
en
pt
en
mi
en
en
es
ja
en
es
it
en
it
en
es
it
de
und
it
en
en
pt
en
en
en
en
es
en
sv
en
hr
pt
en
de
es
fr
en
fr
en
en
en
en
en
en
en
pt
es
es
en
en
mi
es
en
en
en
it
it
es
la
en
en
en
it
es
en
en
pt
en
en
en
en
en
it
fr
en
en
pt
en
en
en
en
en
it
en
en
nl
ja
it
de
en
en
en
en
en
es
en
es
en
en
en
es
en
en
es
en
es
en
ko
es
en
es
fr
en
en
en
en
en
en
en
en
pl
en
es
en
fr
en
es
en
vi
en
fr
en
en
fr
es
en
en
en
en
fr
ro
en
en
en
it
ja
de
nl
es
en
en
en
en
en
en
it
en
es
en
nl
en
es
en
en
en
en
en
en
en
en
en
en
en
hr
en
en
en
pt
hu
it
en
en
en
en
pt
en
en
qu
ar
ja
en
en
en
en
en
en
en
en
it
en
hu
en
en
en
fr
en
en
pt
en
en
de
fi
pt
en
en
en
es
en
en
pt
en
it
en
en
en
en
es
ro
pt
en
en
en
en
en
kk
en
en
fr
en
en
en
en
en
fr
fr
ru
en
it
en
en
en
es
en
en
en
en
en
es
en
fr
es
fr
sv
fr
en
es
en
en
en
en
hu
en
en
id
en
en
fr
en
pt
en
en
en
fr
en
de
en
en
es
en
en
mt
fr
en
en
ar
en
en
pt
en
en
es
en
lb
en
it
en
de
en
en
it
de
en
fr
en
nl
en
en
en
en
en
en
en
fr
en
es
en
it
en
en
de
de
en
la
en
en
en
nl
en
en
en
en
en
tr
es
it
en
en
es
en
en
en
ja
it
en
en
en
en
lv
de
en
en
en
pt
en
en
en
en
en
es
sv
en
en
es
pt
de
pt
en
en
en
ja
en
pt
lt
en
es
it
en
en
en
en
en
en
en
en
es
sv
pt
es
en
en
en
yo
la
en
en
en
hmn
ro
fr
en
en
en
en
ja
en
en
en
en
en
de
es
es
pt
bg
en
cs
es
es
no
en
en
pt
en
en
es
fr
nl
en
en
it
en
en
en
de
es
en
de
en
en
ja
en
en
pt
ja
en
en
en
en
vi
en
en
de
en
en
es
en
en
de
en
en
en
en
de
pt
en
en
en
en
en
fr
en
en
pt
ar
en
nl
en
en
pt
en
en
en
en
en
en
en
ja
en
fr
en
la
tr
it
en
en
es
it
pt
en
en
en
en
en
en
en
es
en
nl
it
nl
en
it
it
en
sk
es
en
cs
de
ar
en
es
en
tr
en
en
en
fr
ja
es
en
en
en
nl
en
id
de
en
en
en
en
en
fr
en
en
nl
pt
en
en
en
en
en
en
en
fr
en
es
en
es
en
en
en
en
de
en
en
en
it
it
de
de
es
en
ca
en
de
es
it
de
en
en
ja
pt
es
nl
en
es
pt
en
en
en
en
en
en
ar
sv
en
en
en
en
ms
en
it
en
en
en
en
pl
en
en
da
en
en
en
en
en
en
en
fr
en
en
es
it
en
en
en
en
en
ja
en
en
en
en
en
en
de
en
en
en
it
en
en
en
en
en
it
en
en
en
it
en
nl
en
fi
en
en
en
en
la
hu
en
hu
en
no
en
en
ko
en
es
en
en
en
en
de
en
it
es
de
en
lb
en
en
en
en
es
tr
it
en
en
it
en
fr
en
en
de
en
es
it
es
en
en
en
en
en
pt
mi
en
pt
en
de
es
en
nl
bg
en
en
af
en
en
en
en
de
es
es
fr
es
en
en
hi
en
en
en
de
nl
en
es
en
ja
en
en
de
en
en
en
en
it
en
en
en
en
en
ja
gl
en
it
en
de
en
en
nl
en
en
en
it
en
en
es
en
en
en
es
es
rw
en
ar
en
en
en
en
en
pt
cs
en
es
en
de
en
ar
en
en
nl
en
en
fr
en
bg
en
en
en
en
de
en
en
uk
fr
en
en
en
en
pt
fr
en
en
en
fr
de
en
en
fr
en
en
en
en
ja
en
tr
en
en
es
es
en
en
en
en
pt
ru
en
en
es
es
en
en
en
sv
de
bg
und
en
sv
en
en
en
en
pt
en
en
en
en
vi
bg
en
es
en
en
en
zh
de
en
en
en
en
en
en
sl
fr
en
es
en
fr
en
la
ru
en
en
es
en
en
en
pt
ja
es
hu
ja
en
pt
sv
de
en
en
en
en
en
id
no
en
hu
nl
en
da
en
ja
en
en
en
en
en
fr
ja
pt
ja
en
en
en
en
en
ja
es
es
da
es
fr
de
eu
en
en
fr
fr
en
es
en
en
sv
en
en
fil
en
no
en
en
en
en
en
en
en
en
en
en
en
en
es
en
en
fr
en
en
en
pt
de
pt
en
en
hu
en
en
it
en
en
en
en
de
it
es
en
it
tr
en
en
en
en
en
la
de
en
pt
en
ar
en
en
en
en
en
fr
de
en
en
pt
tr
es
en
it
ja
fr
es
en
en
en
en
en
en
en
en
es
es
ms
en
en
pt
fr
en
es
en
en
en
en
en
en
en
it
fr
pt
en
en
es
cs
en
en
en
pt
en
it
en
ar
en
en
en
es
en
en
es
en
da
en
en
en
en
en
en
it
en
es
ja
en
fr
mr
en
en
en
en
en
en
en
en
en
en
en
pt
en
en
de
pt
en
en
pt
en
de
en
en
en
en
en
en
sv
en
en
en
en
en
en
es
en
en
en
es
en
pt
en
en
en
en
sv
en
fr
en
en
en
en
de
fr
en
pt
pt
en
en
en
en
en
es
en
fr
pt
en
en
en
pt
en
en
de
et
es
en
en
fr
en
en
pt
en
zh
en
en
es
en
fr
en
de
en
es
de
en
en
pt
pt
en
de
en
en
en
en
en
pt
fy
fr
pt
en
en
en
es
es
fr
en
it
en
es
en
pt
en
en
en
en
hr
en
pt
de
en
en
es
en
pt
it
en
hu
lt
en
en
en
it
en
en
en
en
de
fr
en
en
en
ja
pt
en
fr
en
af
en
da
en
en
pt
en
es
es
en
en
en
en
en
en
en
de
pt
fr
en
en
en
it
en
it
en
en
en
en
en
fr
en
en
fr
de
en
de
en
en
en
de
pt
qu
en
en
en
da
en
en
en
en
ja
en
en
it
en
en
de
en
en
en
en
pt
ja
en
en
ja
it
en
en
en""".split('\n')
df_join_baseline['lang'] = langs
df_join_baseline_en = df_join_baseline[df_join_baseline.lang == 'en']
df_sub_perf_en, df_sub_perf_agg_en = calculate_metrics(df_join_baseline_en, min_prob, valid_paths, 
        y_true_name="y_true", y_pred_name="y_pred", y_prob_name="y_prob")
df_sub_perf_baseline_en, df_sub_perf_agg_baseline_en = calculate_metrics(df_join_baseline_en, min_baseline_weight, 
        valid_paths, y_true_name="y_true", y_pred_name="y_baseline", y_prob_name="y_baseline_prob")
# %%
recs = []
for i in df_join_baseline_en.to_dict('records'):
    i['y_baseline_jc'] = len(set(i['y_true'][:3]).intersection(set(i['y_baseline'][:3]))) / \
        len(set(i['y_true'][:3]).union(set(i['y_baseline'][:3])))
    i['y_pred_jc'] = len(set(i['y_true']).intersection(set(i['y_pred'][:3]))) / \
        len(set(i['y_true'][:3]).union(set(i['y_pred'][:3])))
    recs.append(i)
df_join_baseline_en = pd.DataFrame(recs)
# %%
df_join_baseline_en.to_excel('tmp_test_eval.xlsx')
# %%
